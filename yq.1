'\" t
.\" Automatically generated by Pandoc 2.14.2
.\"
.TH "YQ" "1" "" "" "yq (https://github.com/mikefarah/yq/) version v4.25.1"
.hy
.SH NAME
.PP
\f[I]yq\f[R] is a portable command-line YAML processor
.SH SYNOPSIS
.PP
yq [eval/eval-all] [expression] files..
.PP
eval/e - (default) Apply the expression to each document in each yaml
file in sequence
.PP
eval-all/ea - Loads all yaml documents of all yaml files and runs
expression once
.SH DESCRIPTION
.PP
a lightweight and portable command-line YAML processor.
\f[C]yq\f[R] uses jq (https://github.com/stedolan/jq) like syntax but
works with yaml files as well as json.
It doesn\[cq]t yet support everything \f[C]jq\f[R] does - but it does
support the most common operations and functions, and more is being
added continuously.
.PP
This documentation is also available at https://mikefarah.gitbook.io/yq/
# QUICK GUIDE
.SS Read a value:
.IP
.nf
\f[C]
yq \[aq].a.b[0].c\[aq] file.yaml
\f[R]
.fi
.SS Pipe from STDIN:
.IP
.nf
\f[C]
cat file.yaml | yq \[aq].a.b[0].c\[aq]
\f[R]
.fi
.SS Update a yaml file, inplace
.IP
.nf
\f[C]
yq -i \[aq].a.b[0].c = \[dq]cool\[dq]\[aq] file.yaml
\f[R]
.fi
.SS Update using environment variables
.IP
.nf
\f[C]
NAME=mike yq -i \[aq].a.b[0].c = strenv(NAME)\[aq] file.yaml
\f[R]
.fi
.SS Merge multiple files
.IP
.nf
\f[C]
yq ea \[aq]. as $item ireduce ({}; . * $item )\[aq] path/to/*.yml
\f[R]
.fi
.PP
Note the use of \f[C]ea\f[R] to evaluate all files at once (instead of
in sequence.)
.SS Multiple updates to a yaml file
.IP
.nf
\f[C]
yq -i \[aq]
  .a.b[0].c = \[dq]cool\[dq] |
  .x.y.z = \[dq]foobar\[dq] |
  .person.name = strenv(NAME)
\[aq] file.yaml
\f[R]
.fi
.PP
See the documentation (https://mikefarah.gitbook.io/yq/) for more.
.SH KNOWN ISSUES / MISSING FEATURES
.IP \[bu] 2
\f[C]yq\f[R] attempts to preserve comment positions and whitespace as
much as possible, but it does not handle all scenarios (see
https://github.com/go-yaml/yaml/tree/v3 for details)
.IP \[bu] 2
Powershell has its own\&...opinions:
https://mikefarah.gitbook.io/yq/usage/tips-and-tricks#quotes-in-windows-powershell
.SH BUGS / ISSUES / FEATURE REQUESTS
.PP
Please visit the GitHub page https://github.com/mikefarah/yq/.
.SH HOW IT WORKS
.PP
In \f[C]yq\f[R] expressions are made up of operators and pipes.
A context of nodes is passed through the expression and each operation
takes the context as input and returns a new context as output.
That output is piped in as input for the next operation in the
expression.
To begin with, the context is set to the first yaml document of the
first yaml file (if processing in sequence using eval).
.PP
Lets look at a couple of examples.
.SS Simple assignment example
.PP
Given a document like:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
with an expression:
.IP
.nf
\f[C]
\&.a = .b
\f[R]
.fi
.PP
Like math expression - operator precedence is important.
.PP
The \f[C]=\f[R] operator takes two arguments, a \f[C]lhs\f[R]
expression, which in this case is \f[C].a\f[R] and \f[C]rhs\f[R]
expression which is \f[C].b\f[R].
.PP
It pipes the current, lets call it `root' context through the
\f[C]lhs\f[R] expression of \f[C].a\f[R] to return the node
.IP
.nf
\f[C]
cat
\f[R]
.fi
.PP
Sidenote: this node holds not only its value `cat', but comments and
metadata too, including path and parent information.
.PP
The \f[C]=\f[R] operator then pipes the `root' context through the
\f[C]rhs\f[R] expression of \f[C].b\f[R] to return the node
.IP
.nf
\f[C]
dog
\f[R]
.fi
.PP
Both sides have now been evaluated, so now the operator copies across
the value from the RHS (\f[C].b\f[R]) to the the LHS (\f[C].a\f[R]), and
it returns the now updated context:
.IP
.nf
\f[C]
a: dog
b: dog
\f[R]
.fi
.SS Complex assignment, operator precedence rules
.PP
Just like math expression - \f[C]yq\f[R] expression have an order of
precedence.
The pipe \f[C]|\f[R] operator has a low order of precedence, so
operators with higher precedence will get evalated first.
.PP
Most of the time, this is intuitively what you\[cq]d want, for instance
\f[C].a = \[dq]cat\[dq] | .b = \[dq]dog\[dq]\f[R] is effectively:
\f[C](.a = \[dq]cat\[dq]) | (.b = \[dq]dog\[dq])\f[R].
.PP
However, this is not always the case, particularly if you have a complex
LHS or RHS expression, for instance if you want to select particular
nodes to update.
.PP
Lets say you had:
.IP
.nf
\f[C]
- name: bob
  fruit: apple
- name: sally
  fruit: orange
\f[R]
.fi
.PP
Lets say you wanted to update the \f[C]sally\f[R] entry to have fruit:
`mango'.
The \f[I]incorrect\f[R] way to do that is:
\f[C].[] | select(.name == \[dq]sally\[dq]) | .fruit = \[dq]mango\[dq]\f[R].
.PP
Becasue \f[C]|\f[R] has a low operator precedence, this will be
evaluated (\f[I]incorrectly\f[R]) as :
\f[C](.[]) | (select(.name == \[dq]sally\[dq])) | (.fruit = \[dq]mango\[dq])\f[R].
What you\[cq]ll see is only the updated segment returned:
.IP
.nf
\f[C]
name: sally
fruit: mango
\f[R]
.fi
.PP
To properly update this yaml, you will need to use brackets (think
BODMAS from maths) and wrap the entire LHS:
\f[C](.[] | select(.name == \[dq]sally\[dq]) | .fruit) = \[dq]mango\[dq]\f[R]
.PP
Now that entire LHS expression is passed to the `assign' (\f[C]=\f[R])
operator, and the yaml is correctly updated and returned:
.IP
.nf
\f[C]
- name: bob
  fruit: apple
- name: sally
  fruit: mango
\f[R]
.fi
.SS Relative update (e.g.\ \f[C]|=\f[R])
.PP
There is another form of the \f[C]=\f[R] operator which we call the
relative form.
It\[cq]s very similar to \f[C]=\f[R] but with one key difference when
evaluating the RHS expression.
.PP
In the plain form, we pass in the `root' level context to the RHS
expression.
In relative form, we pass in \f[I]each result of the LHS\f[R] to the RHS
expression.
Let\[cq]s go through an example.
.PP
Given a document like:
.IP
.nf
\f[C]
a: 1
b: thing
\f[R]
.fi
.PP
with an expression:
.IP
.nf
\f[C]
\&.a |= . + 1
\f[R]
.fi
.PP
Similar to the \f[C]=\f[R] operator, \f[C]|=\f[R] takes two operands,
the LHS and RHS.
.PP
It pipes the current context (the whole document) through the LHS
expression of \f[C].a\f[R] to get the node value:
.IP
.nf
\f[C]
1
\f[R]
.fi
.PP
Now it pipes \f[I]that LHS context\f[R] into the RHS expression
\f[C]. + 1\f[R] (whereas in the \f[C]=\f[R] plain form it piped the
original document context into the RHS) to yield:
.IP
.nf
\f[C]
2
\f[R]
.fi
.PP
The assignment operator then copies across the value from the RHS to the
value on the LHS, and it returns the now updated `root' context:
.IP
.nf
\f[C]
a: 2
b: thing
\f[R]
.fi
.SH Add
.PP
Add behaves differently according to the type of the LHS: * arrays:
concatenate * number scalars: arithmetic addition * string scalars:
concatenate * maps: shallow merge (use the multiply operator
(\f[C]*\f[R]) to deeply merge)
.PP
Use \f[C]+=\f[R] as a relative append assign for things like increment.
Note that \f[C].a += .x\f[R] is equivalent to running
\f[C].a = .a + .x\f[R].
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Concatenate arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
b:
  - 3
  - 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
- 4
\f[R]
.fi
.SS Concatenate to existing array
.PP
Note that the styling of \f[C]a\f[R] is kept.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: [1,2]
b:
  - 3
  - 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: [1, 2, 3, 4]
b:
  - 3
  - 4
\f[R]
.fi
.SS Concatenate null to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a + null\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
\f[R]
.fi
.SS Append to existing array
.PP
Note that the styling is copied from existing array elements
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: [\[aq]dog\[aq]]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += \[dq]cat\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: [\[aq]dog\[aq], \[aq]cat\[aq]]
\f[R]
.fi
.SS Add new object to array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - dog: woof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a + {\[dq]cat\[dq]: \[dq]meow\[dq]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- dog: woof
- cat: meow
\f[R]
.fi
.SS Relative append
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  a1:
    b:
      - cat
  a2:
    b:
      - dog
  a3: {}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a[].b += [\[dq]mouse\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  a1:
    b:
      - cat
      - mouse
  a2:
    b:
      - dog
      - mouse
  a3:
    b:
      - mouse
\f[R]
.fi
.SS String concatenation
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: catmeow
b: meow
\f[R]
.fi
.SS Number addition - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.9
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 7.9
b: 4.9
\f[R]
.fi
.SS Number addition - int
.PP
If both the lhs and rhs are ints then the expression will be calculated
with ints.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a + .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 7
b: 4
\f[R]
.fi
.SS Increment numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] += 1\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 4
b: 6
\f[R]
.fi
.SS Date addition
.PP
You can add durations to dates.
Assumes RFC3339 date time format, see date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2021-01-01T00:00:00Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += \[dq]3h10m\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2021-01-01T03:10:00Z
\f[R]
.fi
.SS Date addition - custom format
.PP
You can add durations to dates.
See date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq], .a += \[dq]3h1m\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 6:00AM GMT
\f[R]
.fi
.SS Add to null
.PP
Adding to null simply returns the rhs
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]null + \[dq]cat\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Add maps to shallow merge
.PP
Adding objects together shallow merges them.
Use \f[C]*\f[R] to deeply merge.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing:
    name: Astuff
    value: x
  a1: cool
b:
  thing:
    name: Bstuff
    legs: 3
  b1: neat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  thing:
    name: Bstuff
    legs: 3
  a1: cool
  b1: neat
b:
  thing:
    name: Bstuff
    legs: 3
  b1: neat
\f[R]
.fi
.SS Custom types: that are really strings
.PP
When custom tags are encountered, yq will try to decode the underlying
type.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse cat
b: !goat _meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse cat_meow
b: !goat _meow
\f[R]
.fi
.SS Custom types: that are really numbers
.PP
When custom tags are encountered, yq will try to decode the underlying
type.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse 1.2
b: !goat 2.3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse 3.5
b: !goat 2.3
\f[R]
.fi
.SH Alternative (Default value)
.PP
This operator is used to provide alternative (or default) values when a
particular expression is either null or false.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS LHS is defined
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: bridge
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bridge
\f[R]
.fi
.SS LHS is not defined
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS LHS is null
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[ti]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS LHS is false
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: false
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a // \[dq]hello\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
hello
\f[R]
.fi
.SS RHS is an expression
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: false
b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a // .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SH Anchor and Alias Operators
.PP
Use the \f[C]alias\f[R] and \f[C]anchor\f[R] operators to read and write
yaml aliases and anchors.
The \f[C]explode\f[R] operator normalises a yaml file (dereference (or
expands) aliases and remove anchor names).
.PP
\f[C]yq\f[R] supports merge aliases (like \f[C]<<: *blah\f[R]) however
this is no longer in the standard yaml spec (1.2) and so \f[C]yq\f[R]
will automatically add the \f[C]!!merge\f[R] tag to these nodes as it is
effectively a custom tag.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Merge one map
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<: *CENTER
  r: 10
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
x: 1
y: 2
r: 10
\f[R]
.fi
.SS Merge multiple maps
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<:
    - *CENTER
    - *BIG
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
r: 10
x: 1
y: 2
\f[R]
.fi
.SS Override
.PP
see https://yaml.org/type/merge.html
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- &CENTER
  x: 1
  y: 2
- &LEFT
  x: 0
  y: 2
- &BIG
  r: 10
- &SMALL
  r: 1
- !!merge <<:
    - *BIG
    - *LEFT
    - *SMALL
  x: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[4] | explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
r: 10
x: 1
y: 2
\f[R]
.fi
.SS Get anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &billyBob cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | anchor\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
billyBob
\f[R]
.fi
.SS Set anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a anchor = \[dq]foobar\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: &foobar cat
\f[R]
.fi
.SS Set anchor relatively using assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a anchor |= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: &cat
  b: cat
\f[R]
.fi
.SS Get alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &billyBob meow
a: *billyBob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | alias\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
billyBob
\f[R]
.fi
.SS Set alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a alias = \[dq]meow\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: *meow
\f[R]
.fi
.SS Set alias to blank does nothing
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a alias = \[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: cat
\f[R]
.fi
.SS Set alias relatively using assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: &meow purr
a:
  f: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a alias |= .f\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: &meow purr
a: *meow
\f[R]
.fi
.SS Explode alias and anchor
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
f:
  a: &a cat
  b: *a
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]explode(.f)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
f:
  a: cat
  b: cat
\f[R]
.fi
.SS Explode with no aliases or anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: mike
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]explode(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: mike
\f[R]
.fi
.SS Explode with alias keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
f:
  a: &a cat
  *a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]explode(.f)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
f:
  a: cat
  cat: b
\f[R]
.fi
.SS Explode with merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]explode(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo:
  a: foo_a
  thing: foo_thing
  c: foo_c
bar:
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: bar_b
  thing: foo_thing
  c: foobarList_c
  a: foo_a
foobar:
  c: foo_c
  a: foo_a
  thing: foobar_thing
\f[R]
.fi
.SS Dereference and update a field
.PP
\[ga]Use explode with multiply to dereference an object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
item_value: &item_value
  value: true
thingOne:
  name: item_1
  !!merge <<: *item_value
thingTwo:
  name: item_2
  !!merge <<: *item_value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].thingOne |= explode(.) * {\[dq]value\[dq]: false}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
item_value: &item_value
  value: true
thingOne:
  name: item_1
  value: false
thingTwo:
  name: item_2
  !!merge <<: *item_value
\f[R]
.fi
.SH Assign (Update)
.PP
This operator is used to update node values.
It can be used in either the:
.SS plain form: \f[C]=\f[R]
.PP
Which will assign the LHS node values to the RHS node values.
The RHS expression is run against the matching nodes in the pipeline.
.SS relative form: \f[C]|=\f[R]
.PP
This will do a similar thing to the plain form, however, the RHS
expression is run against \f[I]the LHS nodes\f[R].
This is useful for updating values based on old values, e.g.\ increment.
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Create yaml file
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq].a.b = \[dq]cat\[dq] | .x = \[dq]frog\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: cat
x: frog
\f[R]
.fi
.SS Update node to be the child value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b:
    g: foof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  g: foof
\f[R]
.fi
.SS Double elements in an array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] |= . * 2\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 2
- 4
- 6
\f[R]
.fi
.SS Update node from another file
.PP
Note this will also work when the second file is a scalar
(string/number)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: apples
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
b: bob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]select(fileIndex==0).a = select(fileIndex==1) | select(fileIndex==0)\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: bob
\f[R]
.fi
.SS Update node to be the sibling value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: child
b: sibling
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: sibling
b: sibling
\f[R]
.fi
.SS Updated multiple paths
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: fieldA
b: fieldB
c: fieldC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.a, .c) = \[dq]potatoe\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: potatoe
b: fieldB
c: potatoe
\f[R]
.fi
.SS Update string value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b = \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
\f[R]
.fi
.SS Update string value via |=
.PP
Note there is no difference between \f[C]=\f[R] and \f[C]|=\f[R] when
the RHS is a scalar
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b |= \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
\f[R]
.fi
.SS Update deeply selected results
.PP
Note that the LHS is wrapped in brackets! This is to ensure we dont
first filter out the yaml and then update the snippet.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
  c: cactus
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.a[] | select(. == \[dq]apple\[dq])) = \[dq]frog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: frog
  c: cactus
\f[R]
.fi
.SS Update array values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- candy
- apple
- sandy
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.[] | select(. == \[dq]*andy\[dq])) = \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- bogs
- apple
- bogs
\f[R]
.fi
.SS Update empty object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b |= \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: bogs
\f[R]
.fi
.SS Update node value that has an anchor
.PP
Anchor will remaple
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cool cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = \[dq]dog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: &cool dog
\f[R]
.fi
.SS Update empty object and array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b.[0] |= \[dq]bogs\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    - bogs
\f[R]
.fi
.SH Boolean Operators
.PP
The \f[C]or\f[R] and \f[C]and\f[R] operators take two parameters and
return a boolean result.
.PP
\f[C]not\f[R] flips a boolean from true to false, or vice versa.
.PP
\f[C]any\f[R] will return \f[C]true\f[R] if there are any \f[C]true\f[R]
values in a array sequence, and \f[C]all\f[R] will return true if
\f[I]all\f[R] elements in an array are true.
.PP
\f[C]any_c(condition)\f[R] and \f[C]all_c(condition)\f[R] are like
\f[C]any\f[R] and \f[C]all\f[R] but they take a condition expression
that is used against each element to determine if it\[cq]s
\f[C]true\f[R].
Note: in \f[C]jq\f[R] you can simply pass a condition to \f[C]any\f[R]
or \f[C]all\f[R] and it simply works - \f[C]yq\f[R] isn\[cq]t that
clever..yet
.PP
These are most commonly used with the \f[C]select\f[R] operator to
filter particular nodes.
.SS Related Operators
.IP \[bu] 2
equals / not equals (\f[C]==\f[R], \f[C]!=\f[R]) operators
here (https://mikefarah.gitbook.io/yq/operators/equals)
.IP \[bu] 2
comparison (\f[C]>=\f[R], \f[C]<\f[R] etc) operators
here (https://mikefarah.gitbook.io/yq/operators/compare)
.IP \[bu] 2
select operator here (https://mikefarah.gitbook.io/yq/operators/select)
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS \f[C]or\f[R] example
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]true or false\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]and\f[R] example
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]true and false\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Matching nodes with select, equals and or
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: bird
  b: dog
- a: frog
  b: bird
- a: cat
  b: fly
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][.[] | select(.a == \[dq]cat\[dq] or .b == \[dq]dog\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: bird
  b: dog
- a: cat
  b: fly
\f[R]
.fi
.SS \f[C]any\f[R] returns true if any boolean in a given array is true
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- false
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]any\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]any\f[R] returns false for an empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]any\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS \f[C]any_c\f[R] returns true if any element in the array is true for the given condition.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - rad
  - awesome
b:
  - meh
  - whatever
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] |= any_c(. == \[dq]awesome\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
b: false
\f[R]
.fi
.SS \f[C]all\f[R] returns true if all booleans in a given array are true
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- true
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]all\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]all\f[R] returns true for an empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]all\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS \f[C]all_c\f[R] returns true if all elements in the array are true for the given condition.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - rad
  - awesome
b:
  - meh
  - 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] |= all_c(tag == \[dq]!!str\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
b: false
\f[R]
.fi
.SS Not true is false
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]true | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Not false is true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]false | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS String values considered to be true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]cat\[dq] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Empty string value considered to be true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]\[dq] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Numbers are considered to be true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]1 | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Zero is considered to be true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]0 | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Null is considered to be false
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[ti] | not\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SH Collect into Array
.PP
This creates an array using the expression between the square brackets.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Collect empty
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq][]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
[]
\f[R]
.fi
.SS Collect single
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq][\[dq]cat\[dq]]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
\f[R]
.fi
.SS Collect many
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][.a, .b]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.SH Column
.PP
Returns the column of the matching node.
Starts from 1, 0 indicates there was no column data.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Returns column of \f[I]value\f[R] node
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: bob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b | column\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
4
\f[R]
.fi
.SS Returns column of \f[I]key\f[R] node
.PP
Pipe through the key operator to get the column of the key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: bob
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b | key | column\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS First column is 1
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | key | column\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS No column data is 0
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]{\[dq]a\[dq]: \[dq]new entry\[dq]} | column\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SH Comment Operators
.PP
Use these comment operators to set or retrieve comments.
.PP
Like the \f[C]=\f[R] and \f[C]|=\f[R] assign operators, the same syntax
applies when updating comments:
.SS plain form: \f[C]=\f[R]
.PP
This will assign the LHS nodes comments to the expression on the RHS.
The RHS is run against the matching nodes in the pipeline
.SS relative form: \f[C]|=\f[R]
.PP
Similar to the plain form, however the RHS evaluates against each
matching LHS node! This is useful if you want to set the comments as a
relative expression of the node, for instance its value or path.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Set line comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a line_comment=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat # single
\f[R]
.fi
.SS Use update assign to perform relative updates
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. line_comment |= .\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat # cat
b: dog # dog
\f[R]
.fi
.SS Set head comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. head_comment=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# single

a: cat
\f[R]
.fi
.SS Set foot comment, using an expression
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. foot_comment=.a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat

# cat
\f[R]
.fi
.SS Remove comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # comment
b: dog # leave this
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a line_comment=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog # leave this
\f[R]
.fi
.SS Remove (strip) all comments
.PP
Note the use of \f[C]...\f[R] to ensure key nodes are included.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # comment
# great
b: # key comment
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]... comments=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b:
\f[R]
.fi
.SS Get line comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat # meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | line_comment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
meow
\f[R]
.fi
.SS Get head comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!

a: cat # meow

# have a great day
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. | head_comment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
welcome!
\f[R]
.fi
.SS Head comment with document split
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!
---
# bob
a: cat # meow

# have a great day
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]head_comment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
welcome!
bob
\f[R]
.fi
.SS Get foot comment
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# welcome!

a: cat # meow

# have a great day
# no really
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. | foot_comment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
have a great day
no really
\f[R]
.fi
.SH Compare Operators
.PP
Comparison operators (\f[C]>\f[R], \f[C]>=\f[R], \f[C]<\f[R],
\f[C]<=\f[R]) can be used for comparing scalar values of the same time.
.PP
The following types are currently supported:
.IP \[bu] 2
numbers
.IP \[bu] 2
strings
.IP \[bu] 2
datetimes
.SS Related Operators
.IP \[bu] 2
equals / not equals (\f[C]==\f[R], \f[C]!=\f[R]) operators
here (https://mikefarah.gitbook.io/yq/operators/equals)
.IP \[bu] 2
boolean operators (\f[C]and\f[R], \f[C]or\f[R], \f[C]any\f[R] etc)
here (https://mikefarah.gitbook.io/yq/operators/boolean-operators)
.IP \[bu] 2
select operator here (https://mikefarah.gitbook.io/yq/operators/select)
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Compare numbers (>)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 5
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a > .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Compare equal numbers (>=)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 5
b: 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a >= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Compare strings
.PP
Compares strings by their bytecode.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: zoo
b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a > .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Compare date times
.PP
You can compare date times.
Assumes RFC3339 date time format, see date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2021-01-01T03:10:00Z
b: 2020-01-01T03:10:00Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a > .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Both sides are null: > is false
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq].a > .b\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS Both sides are null: >= is true
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq].a >= .b\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SH Contains
.PP
This returns \f[C]true\f[R] if the context contains the passed in
parameter, and false otherwise.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Array contains array
.PP
Array is equal or subset of
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foobar
- foobaz
- blarp
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]contains([\[dq]baz\[dq], \[dq]bar\[dq]])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Object included in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]foo\[dq]: 12
\[dq]bar\[dq]:
  - 1
  - 2
  - \[dq]barp\[dq]: 12
    \[dq]blip\[dq]: 13
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]contains({\[dq]bar\[dq]: [{\[dq]barp\[dq]: 12}]})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Object not included in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]foo\[dq]: 12
\[dq]bar\[dq]:
  - 1
  - 2
  - \[dq]barp\[dq]: 12
    \[dq]blip\[dq]: 13
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]contains({\[dq]foo\[dq]: 12, \[dq]bar\[dq]: [{\[dq]barp\[dq]: 15}]})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
\f[R]
.fi
.SS String contains substring
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foobar
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]contains(\[dq]bar\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS String equals string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]contains(\[dq]meow\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SH Create, Collect into Object
.PP
This is used to construct objects (or maps).
This can be used against existing yaml, or to create fresh yaml
documents.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Collect empty object
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]{}\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{}
\f[R]
.fi
.SS Wrap (prefix) existing object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]{\[dq]wrap\[dq]: .}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
wrap:
  name: Mike
\f[R]
.fi
.SS Using splat to create multiple objects
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
pets:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]{.name: .pets.[]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Mike: cat
Mike: dog
\f[R]
.fi
.SS Working with multiple documents
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: Mike
pets:
  - cat
  - dog
---
name: Rosey
pets:
  - monkey
  - sheep
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]{.name: .pets.[]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Mike: cat
Mike: dog
Rosey: monkey
Rosey: sheep
\f[R]
.fi
.SS Creating yaml from scratch
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]{\[dq]wrap\[dq]: \[dq]frog\[dq]}\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
wrap: frog
\f[R]
.fi
.SH Date Time
.PP
Various operators for parsing and manipulating dates.
.SS Date time formattings
.PP
This uses the golangs built in time library for parsing and formatting
date times.
.PP
When not specified, the RFC3339 standard is assumed
\f[C]2006-01-02T15:04:05Z07:00\f[R] for parsing.
.PP
To specify a custom parsing format, use the \f[C]with_dtf\f[R] operator.
The first parameter sets the datetime parsing format for the expression
in the second parameter.
The expression can be any valid \f[C]yq\f[R] expression tree.
.IP
.nf
\f[C]
yq \[aq]with_dtf(\[dq]myformat\[dq]; .a + \[dq]3h\[dq] | tz(\[dq]Australia/Melbourne\[dq]))\[aq]
\f[R]
.fi
.PP
See https://pkg.go.dev/time#pkg-constants for examples of formatting
options.
.SS Timezones
.PP
This uses golangs built in LoadLocation function to parse timezones
strings.
See https://pkg.go.dev/time#LoadLocation for more details.
.SS Durations
.PP
Durations are parsed using golangs built in
ParseDuration (https://pkg.go.dev/time#ParseDuration) function.
.PP
You can durations to time using the \f[C]+\f[R] operator.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Format: from standard RFC3339 format
.PP
Providing a single parameter assumes a standard RFC3339 datetime format.
If the target format is not a valid yaml datetime format, the result
will be a string tagged node.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2001-12-15T02:59:43.1Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= format_datetime(\[dq]Monday, 02-Jan-06 at 3:04PM\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM
\f[R]
.fi
.SS Format: from custom date time
.PP
Use with_dtf to set a custom datetime format for parsing.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM\[dq]; format_datetime(\[dq]2006-01-02\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2001-12-15
\f[R]
.fi
.SS Format: get the day of the week
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2001-12-15T02:59:43.1Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | format_datetime(\[dq]Monday\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Saturday
\f[R]
.fi
.SS Now
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cool
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].updated = now\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cool
updated: 2021-05-19T01:02:03Z
\f[R]
.fi
.SS Timezone: from standard RFC3339 format
.PP
Returns a new datetime in the specified timezone.
Specify standard IANA Time Zone format or `utc', `local'.
When given a single parameter, this assumes the datetime is in RFC3339
format.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cool
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].updated = (now | tz(\[dq]Australia/Sydney\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cool
updated: 2021-05-19T11:02:03+10:00
\f[R]
.fi
.SS Timezone: with custom format
.PP
Specify standard IANA Time Zone format or `utc', `local'
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq]; tz(\[dq]Australia/Sydney\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 1:59PM AEDT
\f[R]
.fi
.SS Add and tz custom format
.PP
Specify standard IANA Time Zone format or `utc', `local'
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq]; tz(\[dq]Australia/Sydney\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 1:59PM AEDT
\f[R]
.fi
.SS Date addition
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2021-01-01T00:00:00Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a += \[dq]3h10m\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2021-01-01T03:10:00Z
\f[R]
.fi
.SS Date subtraction
.PP
You can subtract durations from dates.
Assumes RFC3339 date time format, see date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2021-01-01T03:10:00Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a -= \[dq]3h10m\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2021-01-01T00:00:00Z
\f[R]
.fi
.SS Date addition - custom format
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq]; .a += \[dq]3h1m\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 6:00AM GMT
\f[R]
.fi
.SS Date script with custom format
.PP
You can embed full expressions in with_dtf if needed.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq]; .a = (.a + \[dq]3h1m\[dq] | tz(\[dq]Australia/Perth\[dq])))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:00PM AWST
\f[R]
.fi
.SH Delete
.PP
Deletes matching entries in maps or arrays.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Delete entry in map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.b)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.SS Delete nested entry in map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  a1: fred
  a2: frood
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.a.a1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  a2: frood
\f[R]
.fi
.SS Delete entry in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.[1])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 3
\f[R]
.fi
.SS Delete nested entry in array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: cat
  b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.[0].a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- b: dog
\f[R]
.fi
.SS Delete no matches
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.c)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.SS Delete matching entries
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
c: bat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del( .[] | select(. == \[dq]*at\[dq]) )\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: dog
\f[R]
.fi
.SS Recursively delete matching keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  name: frog
  b:
    name: blog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]del(.. | select(has(\[dq]name\[dq])).name)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    age: 12
\f[R]
.fi
.SH Document Index
.PP
Use the \f[C]documentIndex\f[R] operator (or the \f[C]di\f[R] shorthand)
to select nodes of a particular document.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Retrieve a document index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | document_index\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Retrieve a document index, shorthand
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | di\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Filter by document index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]select(document_index == 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Filter by document index shorthand
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]select(di == 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Print Document Index with matches
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
---
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | ({\[dq]match\[dq]: ., \[dq]doc\[dq]: document_index})\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
match: cat
doc: 0
match: frog
doc: 1
\f[R]
.fi
.SH Encoder / Decoder
.PP
Encode operators will take the piped in object structure and encode it
as a string in the desired format.
The decode operators do the opposite, they take a formatted string and
decode it into the relevant object structure.
.PP
Note that you can optionally pass an indent value to the encode
functions (see below).
.PP
These operators are useful to process yaml documents that have
stringified embeded yaml/json/props in them.
.PP
.TS
tab(@);
l l l.
T{
Format
T}@T{
Decode (from string)
T}@T{
Encode (to string)
T}
_
T{
Yaml
T}@T{
from_yaml
T}@T{
to_yaml(i)/\[at]yaml
T}
T{
JSON
T}@T{
from_json
T}@T{
to_json(i)/\[at]json
T}
T{
Properties
T}@T{
from_props
T}@T{
to_props/\[at]props
T}
T{
CSV
T}@T{
T}@T{
to_csv/\[at]csv
T}
T{
TSV
T}@T{
T}@T{
to_tsv/\[at]tsv
T}
T{
XML
T}@T{
from_xml
T}@T{
to_xml(i)/\[at]xml
T}
T{
Base64
T}@T{
\[at]base64d
T}@T{
\[at]base64
T}
.TE
.PP
CSV and TSV format both accept either a single array or scalars
(representing a single row), or an array of array of scalars
(representing multiple rows).
.PP
XML uses the \f[C]--xml-attribute-prefix\f[R] and
\f[C]xml-content-name\f[R] flags to identify attributes and content
fields.
.PP
Base64 assumes rfc4648 (https://rfc-editor.org/rfc/rfc4648.html)
encoding.
Encoding and decoding both assume that the content is a string.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Encode value as json string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | to_json)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: |
  {
    \[dq]cool\[dq]: \[dq]thing\[dq]
  }
\f[R]
.fi
.SS Encode value as json string, on one line
.PP
Pass in a 0 indent to print json on a single line.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | to_json(0))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: \[aq]{\[dq]cool\[dq]:\[dq]thing\[dq]}\[aq]
\f[R]
.fi
.SS Encode value as json string, on one line shorthand
.PP
Pass in a 0 indent to print json on a single line.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | \[at]json)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: \[aq]{\[dq]cool\[dq]:\[dq]thing\[dq]}\[aq]
\f[R]
.fi
.SS Decode a json encoded string
.PP
Keep in mind JSON is a subset of YAML.
If you want idiomatic yaml, pipe through the style operator to clear out
the JSON styling.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[aq]{\[dq]cool\[dq]:\[dq]thing\[dq]}\[aq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | from_json | ... style=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool: thing
\f[R]
.fi
.SS Encode value as props string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | \[at]props)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool: thing
b: |
  cool = thing
\f[R]
.fi
.SS Decode props encoded string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: |-
  cats=great
  dogs=cool as well
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= from_props\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cats: great
  dogs: cool as well
\f[R]
.fi
.SS Encode value as yaml string
.PP
Indent defaults to 2
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
b: |
  cool:
    bob: dylan
\f[R]
.fi
.SS Encode value as yaml string, with custom indentation
.PP
You can specify the indentation level as the first parameter.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | to_yaml(8))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  cool:
    bob: dylan
b: |
  cool:
          bob: dylan
\f[R]
.fi
.SS Decode a yaml encoded string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | from_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
b:
  foo: bar
\f[R]
.fi
.SS Update a multiline encoded yaml string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: |
  foo: bar
  baz: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= (from_yaml | .foo = \[dq]cat\[dq] | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: |
  foo: cat
  baz: dog
\f[R]
.fi
.SS Update a single line encoded yaml string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: \[aq]foo: bar\[aq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= (from_yaml | .foo = \[dq]cat\[dq] | to_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]foo: cat\[aq]
\f[R]
.fi
.SS Encode array of scalars as csv string
.PP
Scalars are strings, numbers and booleans.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- thing1,thing2
- true
- 3.40
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]\[at]csv\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat,\[dq]thing1,thing2\[dq],true,3.40
\f[R]
.fi
.SS Encode array of arrays as csv string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- - cat
  - thing1,thing2
  - true
  - 3.40
- - dog
  - thing3
  - false
  - 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]\[at]csv\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat,\[dq]thing1,thing2\[dq],true,3.40
dog,thing3,false,12
\f[R]
.fi
.SS Encode array of array scalars as tsv string
.PP
Scalars are strings, numbers and booleans.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- - cat
  - thing1,thing2
  - true
  - 3.40
- - dog
  - thing3
  - false
  - 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]\[at]tsv\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat thing1,thing2   true    3.40
dog thing3  false   12
\f[R]
.fi
.SS Encode value as xml string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    foo: bar
    +id: hi
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | to_xml\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<cool id=\[dq]hi\[dq]>
  <foo>bar</foo>
</cool>
\f[R]
.fi
.SS Encode value as xml string on a single line
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    foo: bar
    +id: hi
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | \[at]xml\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<cool id=\[dq]hi\[dq]><foo>bar</foo></cool>
\f[R]
.fi
.SS Encode value as xml string with custom indentation
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cool:
    foo: bar
    +id: hi
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]{\[dq]cat\[dq]: .a | to_xml(1)}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat: |
  <cool id=\[dq]hi\[dq]>
   <foo>bar</foo>
  </cool>
\f[R]
.fi
.SS Decode a xml encoded string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: <foo>bar</foo>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b = (.a | from_xml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: <foo>bar</foo>
b:
  foo: bar
\f[R]
.fi
.SS Encode a string to base64
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
coolData: a special string
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].coolData | \[at]base64\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
YSBzcGVjaWFsIHN0cmluZw==
\f[R]
.fi
.SS Encode a yaml document to base64
.PP
Pipe through \[at]yaml first to convert to a string, then use
\[at]base64 to encode it.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]\[at]yaml | \[at]base64\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
YTogYXBwbGUK
\f[R]
.fi
.SS Decode a base64 encoded string
.PP
Decoded data is assumed to be a string.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
coolData: V29ya3Mgd2l0aCBVVEYtMTYg8J+Yig==
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].coolData | \[at]base64d\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Works with UTF-16 \[u1F60A]
\f[R]
.fi
.SS Decode a base64 encoded yaml document
.PP
Pipe through \f[C]from_yaml\f[R] to parse the decoded base64 string as a
yaml document.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
coolData: YTogYXBwbGUK
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].coolData |= (\[at]base64d | from_yaml)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
coolData:
  a: apple
\f[R]
.fi
.SH Entries
.PP
Similar to the same named functions in \f[C]jq\f[R] these functions
convert to/from an object and an array of key-value pairs.
This is most useful for performing operations on keys of maps.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS to_entries Map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- key: a
  value: 1
- key: b
  value: 2
\f[R]
.fi
.SS to_entries Array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- key: 0
  value: a
- key: 1
  value: b
\f[R]
.fi
.SS to_entries null
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]to_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS from_entries map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]to_entries | from_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.SS from_entries with numeric key indexes
.PP
from_entries always creates a map, even for numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]to_entries | from_entries\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0: a
1: b
\f[R]
.fi
.SS Use with_entries to update keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_entries(.key |= \[dq]KEY_\[dq] + .)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
KEY_a: 1
KEY_b: 2
\f[R]
.fi
.SS Use with_entries to filter the map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: bird
c:
  d: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_entries(select(.value | has(\[dq]b\[dq])))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: bird
\f[R]
.fi
.SH Env Variable Operators
.PP
These operators are used to handle environment variables usage in
expressions and documents.
While environment variables can, of course, be passed in via your CLI
with string interpolation, this often comes with complex quote escaping
and can be tricky to write and read.
.PP
There are three operators:
.IP \[bu] 2
\f[C]env\f[R] which takes a single environment variable name and parse
the variable as a yaml node (be it a map, array, string, number of
boolean)
.IP \[bu] 2
\f[C]strenv\f[R] which also takes a single environment variable name,
and always parses the variable as a string.
.IP \[bu] 2
\f[C]envsubst\f[R] which you pipe strings into and it interpolates
environment variables in strings using
envsubst (https://github.com/a8m/envsubst).
.SS EnvSubst Options
.PP
You can optionally pass envsubst any of the following options:
.IP \[bu] 2
nu: NoUnset, this will fail if there are any referenced variables that
are not set
.IP \[bu] 2
ne: NoEmpty, this will fail if there are any referenced variables that
are empty
.IP \[bu] 2
ff: FailFast, this will abort on the first failure (rather than collect
all the errors)
.PP
E.g: \f[C]envsubst(ne, ff)\f[R] will fail on the first empty variable.
.PP
See Imposing
Restrictions (https://github.com/a8m/envsubst#imposing-restrictions) in
the \f[C]envsubst\f[R] documentation for more information, and below for
examples.
.SS Tip
.PP
To replace environment variables across all values in a document,
\f[C]envsubst\f[R] can be used with the recursive descent operator as
follows:
.IP
.nf
\f[C]
yq \[aq](.. | select(tag == \[dq]!!str\[dq])) |= envsubst\[aq] file.yaml
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Read string environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]cat meow\[dq] yq --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat meow
\f[R]
.fi
.SS Read boolean environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]true\[dq] yq --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: true
\f[R]
.fi
.SS Read numeric environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]12\[dq] yq --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 12
\f[R]
.fi
.SS Read yaml environment variable
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]{b: fish}\[dq] yq --null-input \[aq].a = env(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: {b: fish}
\f[R]
.fi
.SS Read boolean environment variable as a string
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]true\[dq] yq --null-input \[aq].a = strenv(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]true\[dq]
\f[R]
.fi
.SS Read numeric environment variable as a string
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]12\[dq] yq --null-input \[aq].a = strenv(myenv)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]12\[dq]
\f[R]
.fi
.SS Dynamically update a path from an environment variable
.PP
The env variable can be any valid yq expression.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b:
    - name: dog
    - name: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
pathEnv=\[dq].a.b[0].name\[dq]  valueEnv=\[dq]moo\[dq] yq \[aq]eval(strenv(pathEnv)) = strenv(valueEnv)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    - name: moo
    - name: cat
\f[R]
.fi
.SS Dynamic key lookup with environment variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: meow
dog: woof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
myenv=\[dq]cat\[dq] yq \[aq].[env(myenv)]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
meow
\f[R]
.fi
.SS Replace strings with envsubst
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]cat\[dq] yq --null-input \[aq]\[dq]the ${myenv} meows\[dq] | envsubst\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
the cat meows
\f[R]
.fi
.SS Replace strings with envsubst, missing variables
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${myenvnonexisting} meows\[dq] | envsubst\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
the  meows
\f[R]
.fi
.SS Replace strings with envsubst(nu), missing variables
.PP
(nu) not unset, will fail if there are unset (missing) variables
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${myenvnonexisting} meows\[dq] | envsubst(nu)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Error: variable ${myenvnonexisting} not set
\f[R]
.fi
.SS Replace strings with envsubst(ne), missing variables
.PP
(ne) not empty, only validates set variables
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${myenvnonexisting} meows\[dq] | envsubst(ne)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
the  meows
\f[R]
.fi
.SS Replace strings with envsubst(ne), empty variable
.PP
(ne) not empty, will fail if a references variable is empty
.PP
Running
.IP
.nf
\f[C]
myenv=\[dq]\[dq] yq --null-input \[aq]\[dq]the ${myenv} meows\[dq] | envsubst(ne)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Error: variable ${myenv} set but empty
\f[R]
.fi
.SS Replace strings with envsubst, missing variables with defaults
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${myenvnonexisting-dog} meows\[dq] | envsubst\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
the dog meows
\f[R]
.fi
.SS Replace strings with envsubst(nu), missing variables with defaults
.PP
Having a default specified skips over the missing variable.
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${myenvnonexisting-dog} meows\[dq] | envsubst(nu)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
the dog meows
\f[R]
.fi
.SS Replace strings with envsubst(ne), missing variables with defaults
.PP
Fails, because the variable is explicitly set to blank.
.PP
Running
.IP
.nf
\f[C]
myEmptyEnv=\[dq]\[dq] yq --null-input \[aq]\[dq]the ${myEmptyEnv-dog} meows\[dq] | envsubst(ne)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Error: variable ${myEmptyEnv} set but empty
\f[R]
.fi
.SS Replace string environment variable in document
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
v: ${myenv}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
myenv=\[dq]cat meow\[dq] yq \[aq].v |= envsubst\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
v: cat meow
\f[R]
.fi
.SS (Default) Return all envsubst errors
.PP
By default, all errors are returned at once.
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${notThere} ${alsoNotThere}\[dq] | envsubst(nu)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Error: variable ${notThere} not set
variable ${alsoNotThere} not set
\f[R]
.fi
.SS Fail fast, return the first envsubst error (and abort)
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]\[dq]the ${notThere} ${alsoNotThere}\[dq] | envsubst(nu,ff)\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Error: variable ${notThere} not set
\f[R]
.fi
.SH Equals / Not Equals
.PP
This is a boolean operator that will return \f[C]true\f[R] if the LHS is
equal to the RHS and \f[C]false\f[R] otherwise.
.IP
.nf
\f[C]
\&.a == .b
\f[R]
.fi
.PP
It is most often used with the select operator to find particular nodes:
.IP
.nf
\f[C]
select(.a == .b)
\f[R]
.fi
.PP
The not equals \f[C]!=\f[R] operator returns \f[C]false\f[R] if the LHS
is equal to the RHS.
.SS Related Operators
.IP \[bu] 2
comparison (\f[C]>=\f[R], \f[C]<\f[R] etc) operators
here (https://mikefarah.gitbook.io/yq/operators/compare)
.IP \[bu] 2
boolean operators (\f[C]and\f[R], \f[C]or\f[R], \f[C]any\f[R] etc)
here (https://mikefarah.gitbook.io/yq/operators/boolean-operators)
.IP \[bu] 2
select operator here (https://mikefarah.gitbook.io/yq/operators/select)
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | (. == \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
true
false
\f[R]
.fi
.SS Don\[cq]t match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | (. != \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
false
true
\f[R]
.fi
.SS Match number
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 3
- 4
- 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | (. == 4)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
true
false
\f[R]
.fi
.SS Dont match number
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 3
- 4
- 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | (. != 4)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
false
true
\f[R]
.fi
.SS Match nulls
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]null == \[ti]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
\f[R]
.fi
.SS Non exisitant key doesn\[cq]t equal a value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]select(.b != \[dq]thing\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SS Two non existent keys are equal
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]select(.b == .c)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.SH Eval
.PP
Use \f[C]eval\f[R] to dynamically process an expression - for instance
from an environment variable.
.PP
\f[C]eval\f[R] takes a single argument, and evaluates that as a
\f[C]yq\f[R] expression.
Any valid expression can be used, beit a path
\f[C].a.b.c | select(. == \[dq]cat\[dq])\f[R], or an update
\f[C].a.b.c = \[dq]gogo\[dq]\f[R].
.PP
Tip: This can be useful way parameterise complex scripts.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Dynamically evaluate a path
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
pathExp: .a.b[] | select(.name == \[dq]cat\[dq])
a:
  b:
    - name: dog
    - name: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]eval(.pathExp)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
name: cat
\f[R]
.fi
.SS Dynamically update a path from an environment variable
.PP
The env variable can be any valid yq expression.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b:
    - name: dog
    - name: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
pathEnv=\[dq].a.b[0].name\[dq]  valueEnv=\[dq]moo\[dq] yq \[aq]eval(strenv(pathEnv)) = strenv(valueEnv)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    - name: moo
    - name: cat
\f[R]
.fi
.SH File Operators
.PP
File operators are most often used with merge when needing to merge
specific files together.
Note that when doing this, you will need to use \f[C]eval-all\f[R] to
ensure all yaml documents are loaded into memory before performing the
merge (as opposed to \f[C]eval\f[R] which runs the expression once per
document).
.PP
Note that the \f[C]fileIndex\f[R] operator has a short alias of
\f[C]fi\f[R].
.SS Merging files
.PP
Note the use of eval-all to ensure all documents are loaded into memory.
.IP
.nf
\f[C]
yq eval-all \[aq]select(fi == 0) * select(filename == \[dq]file2.yaml\[dq])\[aq] file1.yaml file2.yaml
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Get filename
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]filename\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
sample.yml
\f[R]
.fi
.SS Get file index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]file_index\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SS Get file indices of multiple documents
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]file_index\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
---
1
\f[R]
.fi
.SS Get file index alias
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]fi\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SH Flatten
.PP
This recursively flattens arrays.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Flatten
.PP
Recursively flattens all arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- - 2
- - - 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.SS Flatten with depth of one
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- - 2
- - - 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]flatten(1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- - 3
\f[R]
.fi
.SS Flatten empty array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
[]
\f[R]
.fi
.SS Flatten array of objects
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foo: bar
- - foo: baz
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]flatten\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- foo: bar
- foo: baz
\f[R]
.fi
.SH Group By
.PP
This is used to group items in an array by an expression.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Group by field
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- foo: 1
  bar: 10
- foo: 3
  bar: 100
- foo: 1
  bar: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]group_by(.foo)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- - foo: 1
    bar: 10
  - foo: 1
    bar: 1
- - foo: 3
    bar: 100
\f[R]
.fi
.SS Group by field, with nuls
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat: dog
- foo: 1
  bar: 10
- foo: 3
  bar: 100
- no: foo for you
- foo: 1
  bar: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]group_by(.foo)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- - cat: dog
  - no: foo for you
- - foo: 1
    bar: 10
  - foo: 1
    bar: 1
- - foo: 3
    bar: 100
\f[R]
.fi
.SH Has
.PP
This is operation that returns true if the key exists in a map (or index
in an array), false otherwise.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Has map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: yes
- a: \[ti]
- a:
- b: nope
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | has(\[dq]a\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
true
true
false
\f[R]
.fi
.SS Select, checking for existence of deep paths
.PP
Simply pipe in parent expressions into \f[C]has\f[R]
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a:
    b:
      c: cat
- a:
    b:
      d: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(.a.b | has(\[dq]c\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b:
    c: cat
\f[R]
.fi
.SS Has array index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- []
- [1]
- [1, 2]
- [1, null]
- [1, 2, 3]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | has(1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
false
false
true
true
true
\f[R]
.fi
.SH Keys
.PP
Use the \f[C]keys\f[R] operator to return map keys or array indices.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Map keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
dog: woof
cat: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]keys\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- dog
- cat
\f[R]
.fi
.SS Array keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- apple
- banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]keys\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 0
- 1
\f[R]
.fi
.SS Retrieve array key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[1] | key\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS Retrieve map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | key\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a
\f[R]
.fi
.SS No key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]key\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Update map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  x: 3
  y: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.a.x | key) = \[dq]meow\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  meow: 3
  y: 4
\f[R]
.fi
.SS Get comment from map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  # comment on key
  x: 3
  y: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.x | key | headComment\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
comment on key
\f[R]
.fi
.SH Length
.PP
Returns the lengths of the nodes.
Length is defined according to the type of the node.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS String length
.PP
returns length of string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
3
\f[R]
.fi
.SS null length
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SS Map length
.PP
returns number of entries
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
c: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
2
\f[R]
.fi
.SS Array length
.PP
returns number of elements
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 2
- 4
- 6
- 8
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]length\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
4
\f[R]
.fi
.SH Line
.PP
Returns the line of the matching node.
Starts from 1, 0 indicates there was no line data.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Returns line of \f[I]value\f[R] node
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b:
  c: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b | line\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
3
\f[R]
.fi
.SS Returns line of \f[I]key\f[R] node
.PP
Pipe through the key operator to get the line of the key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b:
  c: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b | key| line\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
2
\f[R]
.fi
.SS First line is 1
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | line\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS No line data is 0
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]{\[dq]a\[dq]: \[dq]new entry\[dq]} | line\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
0
\f[R]
.fi
.SH Load
.PP
The load operators allows you to load in content from another file.
.PP
Note that you can use string operators like \f[C]+\f[R] and
\f[C]sub\f[R] to modify the value in the yaml file to a path that exists
in your system.
.PP
You can load files of the following supported types:
.PP
.TS
tab(@);
l l.
T{
Format
T}@T{
Load Operator
T}
_
T{
Yaml
T}@T{
load
T}
T{
XML
T}@T{
load_xml
T}
T{
Properties
T}@T{
load_props
T}
T{
Plain String
T}@T{
load_str
T}
T{
Base64
T}@T{
load_base64
T}
.TE
.SS Samples files for tests:
.SS yaml
.PP
\f[C]../../examples/thing.yml\f[R]:
.IP
.nf
\f[C]
a: apple is included
b: cool
\f[R]
.fi
.SS xml
.PP
\f[C]small.xml\f[R]:
.IP
.nf
\f[C]
<this>is some xml</this>
\f[R]
.fi
.SS properties
.PP
\f[C]small.properties\f[R]:
.IP
.nf
\f[C]
this.is = a properties file
\f[R]
.fi
.SS base64
.PP
\f[C]base64.txt\f[R]:
.IP
.nf
\f[C]
bXkgc2VjcmV0IGNoaWxsaSByZWNpcGUgaXMuLi4u
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Simple example
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
myFile: ../../examples/thing.yml
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]load(.myFile)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: apple is included
b: cool.
\f[R]
.fi
.SS Replace node with referenced file
.PP
Note that you can modify the filename in the load operator if needed.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
something:
  file: thing.yml
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].something |= load(\[dq]../../examples/\[dq] + .file)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
something:
  a: apple is included
  b: cool.
\f[R]
.fi
.SS Replace \f[I]all\f[R] nodes with referenced file
.PP
Recursively match all the nodes (\f[C]..\f[R]) and then filter the ones
that have a `file' attribute.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
something:
  file: thing.yml
over:
  here:
    - file: thing.yml
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.. | select(has(\[dq]file\[dq]))) |= load(\[dq]../../examples/\[dq] + .file)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
something:
  a: apple is included
  b: cool.
over:
  here:
    - a: apple is included
      b: cool.
\f[R]
.fi
.SS Replace node with referenced file as string
.PP
This will work for any text based file
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
something:
  file: thing.yml
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].something |= load_str(\[dq]../../examples/\[dq] + .file)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
something: |-
  a: apple is included
  b: cool.
\f[R]
.fi
.SS Load from XML
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cool: things
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].more_stuff = load_xml(\[dq]../../examples/small.xml\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool: things
more_stuff:
  this: is some xml
\f[R]
.fi
.SS Load from Properties
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cool: things
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].more_stuff = load_props(\[dq]../../examples/small.properties\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool: things
more_stuff:
  this:
    is: a properties file
\f[R]
.fi
.SS Merge from properties
.PP
This can be used as a convenient way to update a yaml document
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
this:
  is: from yaml
  cool: ay
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. *= load_props(\[dq]../../examples/small.properties\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
this:
  is: a properties file
  cool: ay
\f[R]
.fi
.SS Load from base64 encoded file
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cool: things
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].more_stuff = load_base64(\[dq]../../examples/base64.txt\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool: things
more_stuff: my secret chilli recipe is....
\f[R]
.fi
.SH Map
.PP
Maps values of an array.
Use \f[C]map_values\f[R] to map values of an object.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Map array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]map(. + 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 2
- 3
- 4
\f[R]
.fi
.SS Map object values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 1
b: 2
c: 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]map_values(. + 1)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2
b: 3
c: 4
\f[R]
.fi
.SH Multiply (Merge)
.PP
Like the multiple operator in jq, depending on the operands, this
multiply operator will do different things.
Currently numbers, arrays and objects are supported.
.SS Objects and arrays - merging
.PP
Objects are merged deeply matching on matching keys.
By default, array values override and are not deeply merged.
.PP
Note that when merging objects, this operator returns the merged object
(not the parent).
This will be clearer in the examples below.
.SS Merge Flags
.PP
You can control how objects are merged by using one or more of the
following flags.
Multiple flags can be used together, e.g.\ \f[C].a *+? .b\f[R].
See examples below
.IP \[bu] 2
\f[C]+\f[R] append arrays
.IP \[bu] 2
\f[C]d\f[R] deeply merge arrays
.IP \[bu] 2
\f[C]?\f[R] only merge \f[I]existing\f[R] fields
.IP \[bu] 2
\f[C]n\f[R] only merge \f[I]new\f[R] fields
.SS Merge two files together
.PP
This uses the load operator to merge file2 into file1.
.IP
.nf
\f[C]
yq \[aq]. *= load(\[dq]file2.yml\[dq])\[aq] file1.yml
\f[R]
.fi
.SS Merging all files
.PP
Note the use of \f[C]eval-all\f[R] to ensure all documents are loaded
into memory.
.IP
.nf
\f[C]
yq eval-all \[aq]. as $item ireduce ({}; . * $item )\[aq] *.yml
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Multiply integers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 12
b: 4
\f[R]
.fi
.SS Merge objects together, returning merged result only
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  field: me
  fieldA: cat
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
field:
  g: wizz
fieldA: cat
fieldB: dog
\f[R]
.fi
.SS Merge objects together, returning parent object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  field: me
  fieldA: cat
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  field:
    g: wizz
  fieldA: cat
  fieldB: dog
b:
  field:
    g: wizz
  fieldB: dog
\f[R]
.fi
.SS Merge keeps style of LHS
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: {things: great}
b:
  also: \[dq]me\[dq]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: {things: great, also: \[dq]me\[dq]}
b:
  also: \[dq]me\[dq]
\f[R]
.fi
.SS Merge arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - 1
  - 2
  - 3
b:
  - 3
  - 4
  - 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. * {\[dq]a\[dq]:.b}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  - 3
  - 4
  - 5
b:
  - 3
  - 4
  - 5
\f[R]
.fi
.SS Merge, only existing fields
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing: one
  cat: frog
b:
  missing: two
  thing: two
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *? .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
thing: two
cat: frog
\f[R]
.fi
.SS Merge, only new fields
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing: one
  cat: frog
b:
  missing: two
  thing: two
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *n .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
thing: one
cat: frog
missing: two
\f[R]
.fi
.SS Merge, appending arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  array:
    - 1
    - 2
    - animal: dog
  value: coconut
b:
  array:
    - 3
    - 4
    - animal: cat
  value: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *+ .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
array:
  - 1
  - 2
  - animal: dog
  - 3
  - 4
  - animal: cat
value: banana
\f[R]
.fi
.SS Merge, only existing fields, appending arrays
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  thing:
    - 1
    - 2
b:
  thing:
    - 3
    - 4
  another:
    - 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *?+ .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
thing:
  - 1
  - 2
  - 3
  - 4
\f[R]
.fi
.SS Merge, deeply merging arrays
.PP
Merging arrays deeply means arrays are merge like objects, with indexes
as their key.
In this case, we merge the first item in the array, and do nothing with
the second.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - name: fred
    age: 12
  - name: bob
    age: 32
b:
  - name: fred
    age: 34
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a *d .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: fred
  age: 34
- name: bob
  age: 32
\f[R]
.fi
.SS Merge arrays of objects together, matching on a key
.PP
This is a fairly complex expression - you can use it as is by providing
the environment variables as seen in the example below.
.PP
It merges in the array provided in the second file into the first -
matching on equal keys.
.PP
Explanation:
.PP
The approach, at a high level, is to reduce into a merged map (keyed by
the unique key) and then convert that back into an array.
.PP
First the expression will create a map from the arrays keyed by the
idPath, the unique field we want to merge by.
The reduce operator is merging `({}; . * $item )', so array elements
with the matching key will be merged together.
.PP
Next, we convert the map back to an array, using reduce again,
concatenating all the map values together.
.PP
Finally, we set the result of the merged array back into the first doc.
.PP
Thanks Kev from
stackoverflow (https://stackoverflow.com/a/70109529/1168223)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
myArray:
  - a: apple
    b: appleB
  - a: kiwi
    b: kiwiB
  - a: banana
    b: bananaB
something: else
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
newArray:
  - a: banana
    c: bananaC
  - a: apple
    b: appleB2
  - a: dingo
    c: dingoC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
idPath=\[dq].a\[dq]  originalPath=\[dq].myArray\[dq]  otherPath=\[dq].newArray\[dq] yq eval-all \[aq]
(
  (( (eval(strenv(originalPath)) + eval(strenv(otherPath)))  | .[] | {(eval(strenv(idPath))):  .}) as $item ireduce ({}; . * $item )) as $uniqueMap
  | ( $uniqueMap  | to_entries | .[]) as $item ireduce([]; . + $item.value)
) as $mergedArray
| select(fi == 0) | (eval(strenv(originalPath))) = $mergedArray
\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
myArray:
  - a: apple
    b: appleB2
  - a: kiwi
    b: kiwiB
  - a: banana
    b: bananaB
    c: bananaC
  - a: dingo
    c: dingoC
something: else
\f[R]
.fi
.SS Merge to prefix an element
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. * {\[dq]a\[dq]: {\[dq]c\[dq]: .a}}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  c: cat
b: dog
\f[R]
.fi
.SS Merge with simple aliases
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b:
  f: *cat
c:
  g: thongs
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].c * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
g: thongs
f: *cat
\f[R]
.fi
.SS Merge copies anchor names
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  c: &cat frog
b:
  f: *cat
c:
  g: thongs
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].c * .a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
g: thongs
c: &cat frog
\f[R]
.fi
.SS Merge with merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar * .foobarList\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
c: foobarList_c
!!merge <<:
  - *foo
  - *bar
thing: foobar_thing
b: foobarList_b
\f[R]
.fi
.SS Custom types: that are really numbers
.PP
When custom tags are encountered, yq will try to decode the underlying
type.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse 2
b: !goat 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse 6
b: !goat 3
\f[R]
.fi
.SS Custom types: that are really maps
.PP
Custom tags will be maintained.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse
  cat: meow
b: !goat
  dog: woof
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a * .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse
  cat: meow
  dog: woof
b: !goat
  dog: woof
\f[R]
.fi
.SH Parent
.PP
Parent simply returns the parent nodes of the matching nodes.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Simple example
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  nested: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.nested | parent\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
nested: cat
\f[R]
.fi
.SS Parent of nested matches
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  fruit: apple
  name: bob
b:
  fruit: banana
  name: sam
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. | select(. == \[dq]banana\[dq]) | parent\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
fruit: banana
name: sam
\f[R]
.fi
.SS No parent
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]parent\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SH Path
.PP
The path operator can be used to get the traversal paths of matching
nodes in an expression.
The path is returned as an array, which if traversed in order will lead
to the matching node.
.PP
You can get the key/index of matching nodes by using the \f[C]path\f[R]
operator to return the path array then piping that through
\f[C].[-1]\f[R] to get the last element of that array, the key.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Map path
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b | path\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a
- b
\f[R]
.fi
.SS Get map key
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b | path | .[-1]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b
\f[R]
.fi
.SS Array path
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.[] | select(. == \[dq]dog\[dq]) | path\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a
- 1
\f[R]
.fi
.SS Get array index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.[] | select(. == \[dq]dog\[dq]) | path | .[-1]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS Print path and value
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - cat
  - dog
  - frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a[] | select(. == \[dq]*og\[dq]) | [{\[dq]path\[dq]:path, \[dq]value\[dq]:.}]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- path:
    - a
    - 1
  value: dog
- path:
    - a
    - 2
  value: frog
\f[R]
.fi
.SH Pick
.PP
Filter a map by the specified list of keys.
Map is returned with the key in the order of the pick list.
.PP
Similarly, filter an array by the specified list of indices.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Pick keys from map
.PP
Note that the order of the keys matches the pick order and non existent
keys are skipped.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
myMap:
  cat: meow
  dog: bark
  thing: hamster
  hamster: squeek
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].myMap |= pick([\[dq]hamster\[dq], \[dq]cat\[dq], \[dq]goat\[dq]])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
myMap:
  hamster: squeek
  cat: meow
\f[R]
.fi
.SS Pick indices from array
.PP
Note that the order of the indexes matches the pick order and non
existent indexes are skipped.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- leopard
- lion
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]pick([2, 0, 734, -5])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- lion
- cat
\f[R]
.fi
.SH Pipe
.PP
Pipe the results of an expression into another.
Like the bash operator.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Simple Pipe
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a | .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Multiple updates
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cow
b: sheep
c: same
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = \[dq]cat\[dq] | .b = \[dq]dog\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
c: same
\f[R]
.fi
.SH Recursive Descent (Glob)
.PP
This operator recursively matches (or globs) all children nodes given of
a particular element, including that node itself.
This is most often used to apply a filter recursively against all
matches.
It can be used in either the
.SS match values form \f[C]..\f[R]
.PP
This will, like the \f[C]jq\f[R] equivalent, recursively match all
\f[I]value\f[R] nodes.
Use it to find/manipulate particular values.
.PP
For instance to set the \f[C]style\f[R] of all \f[I]value\f[R] nodes in
a yaml doc, excluding map keys:
.IP
.nf
\f[C]
yq \[aq].. style= \[dq]flow\[dq]\[aq] file.yaml
\f[R]
.fi
.SS match values and map keys form \f[C]...\f[R]
.PP
The also includes map keys in the results set.
This is particularly useful in YAML as unlike JSON, map keys can have
their own styling, tags and use anchors and aliases.
.PP
For instance to set the \f[C]style\f[R] of all nodes in a yaml doc,
including the map keys:
.IP
.nf
\f[C]
yq \[aq]... style= \[dq]flow\[dq]\[aq] file.yaml
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Recurse map (values only)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]..\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
frog
\f[R]
.fi
.SS Recursively find nodes with keys
.PP
Note that this example has wrapped the expression in \f[C][]\f[R] to
show that there are two matches returned.
You do not have to wrap in \f[C][]\f[R] in your path expression.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  name: frog
  b:
    name: blog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][.. | select(has(\[dq]name\[dq]))]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: frog
  b:
    name: blog
    age: 12
- name: blog
  age: 12
\f[R]
.fi
.SS Recursively find nodes with values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  nameA: frog
  b:
    nameB: frog
    age: 12
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. | select(. == \[dq]frog\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
frog
\f[R]
.fi
.SS Recurse map (values and keys)
.PP
Note that the map key appears in the results
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]...\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: frog
a
frog
\f[R]
.fi
.SS Aliases are not traversed
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][..]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: &cat
    c: frog
  b: *cat
- &cat
  c: frog
- frog
- *cat
\f[R]
.fi
.SS Merge docs are not traversed
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar | [..]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
- foobar_c
- *foo
- foobar_thing
\f[R]
.fi
.SH Reduce
.PP
Reduce is a powerful way to process a collection of data into a new
form.
.IP
.nf
\f[C]
<exp> as $<name> ireduce (<init>; <block>)
\f[R]
.fi
.PP
e.g.
.IP
.nf
\f[C]
\&.[] as $item ireduce (0; . + $item)
\f[R]
.fi
.PP
On the LHS we are configuring the collection of items that will be
reduced \f[C]<exp>\f[R] as well as what each element will be called
\f[C]$<name>\f[R].
Note that the array has been splatted into its individual elements.
.PP
On the RHS there is \f[C]<init>\f[R], the starting value of the
accumulator and \f[C]<block>\f[R], the expression that will update the
accumulator for each element in the collection.
Note that within the block expression, \f[C].\f[R] will evaluate to the
current value of the accumulator.
.SS yq vs jq syntax
.PP
Reduce syntax in \f[C]yq\f[R] is a little different from \f[C]jq\f[R] -
as \f[C]yq\f[R] (currently) isn\[cq]t as sophisticated as \f[C]jq\f[R]
and its only supports infix notation (e.g.\ a + b, where the operator is
in the middle of the two parameters) - where as \f[C]jq\f[R] uses a mix
of infix notation with \f[I]prefix\f[R] notation
(e.g.\ \f[C]reduce a b\f[R] is like writing \f[C]+ a b\f[R]).
.PP
To that end, the reduce operator is called \f[C]ireduce\f[R] for
backwards compatability if a \f[C]jq\f[R] like prefix version of
\f[C]reduce\f[R] is ever added.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Sum numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 10
- 2
- 5
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] as $item ireduce (0; . + $item)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
20
\f[R]
.fi
.SS Merge all yaml files together
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
And another sample another.yml file of:
.IP
.nf
\f[C]
b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq eval-all \[aq]. as $item ireduce ({}; . * $item )\[aq] sample.yml another.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: dog
\f[R]
.fi
.SS Convert an array to an object
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- name: Cathy
  has: apples
- name: Bob
  has: bananas
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] as $item ireduce ({}; .[$item | .name] = ($item | .has) )\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
Cathy: apples
Bob: bananas
\f[R]
.fi
.SH Reverse
.PP
Reverses the order of the items in an array
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Reverse
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]reverse\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 3
- 2
- 1
\f[R]
.fi
.SS Sort descending by string field
.PP
Use sort with reverse to sort in descending order.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: banana
- a: cat
- a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_by(.a) | reverse\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: cat
- a: banana
- a: apple
\f[R]
.fi
.SH Select
.PP
Select is used to filter arrays and maps by a boolean expression.
.SS Related Operators
.IP \[bu] 2
equals / not equals (\f[C]==\f[R], \f[C]!=\f[R]) operators
here (https://mikefarah.gitbook.io/yq/operators/equals)
.IP \[bu] 2
comparison (\f[C]>=\f[R], \f[C]<\f[R] etc) operators
here (https://mikefarah.gitbook.io/yq/operators/compare)
.IP \[bu] 2
boolean operators (\f[C]and\f[R], \f[C]or\f[R], \f[C]any\f[R] etc)
here (https://mikefarah.gitbook.io/yq/operators/boolean-operators)
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Select elements from array using wildcard prefix
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(. == \[dq]*at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
goat
\f[R]
.fi
.SS Select elements from array using wildcard suffix
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- go-kart
- goat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(. == \[dq]go*\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
go-kart
goat
\f[R]
.fi
.SS Select elements from array using wildcard prefix and suffix
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- ago
- go
- meow
- going
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(. == \[dq]*go*\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
ago
go
going
\f[R]
.fi
.SS Select elements from array with regular expression
.PP
See more regular expression examples under the \f[C]string\f[R] operator
docs.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- this_0
- not_this
- nor_0_this
- thisTo_4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(test(\[dq][a-zA-Z]+_[0-9]$\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
this_0
thisTo_4
\f[R]
.fi
.SS Select items from a map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
things: cat
bob: goat
horse: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | select(. == \[dq]cat\[dq] or test(\[dq]og$\[dq]))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
dog
\f[R]
.fi
.SS Use select and with_entries to filter map keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
name: bob
legs: 2
game: poker
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_entries(select(.key | test(\[dq]ame$\[dq])))\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
name: bob
game: poker
\f[R]
.fi
.SS Select multiple items in a map and update
.PP
Note the brackets around the entire LHS.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  things: cat
  bob: goat
  horse: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.a.[] | select(. == \[dq]cat\[dq] or . == \[dq]goat\[dq])) |= \[dq]rabbit\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  things: rabbit
  bob: rabbit
  horse: dog
\f[R]
.fi
.SH Sort Keys
.PP
The Sort Keys operator sorts maps by their keys (based on their string
value).
This operator does not do anything to arrays or scalars (so you can
easily recursively apply it to all maps).
.PP
Sort is particularly useful for diffing two different yaml documents:
.IP
.nf
\f[C]
yq -i -P \[aq]sort_keys(..)\[aq] file1.yml
yq -i -P \[aq]sort_keys(..)\[aq] file2.yml
diff file1.yml file2.yml
\f[R]
.fi
.PP
Note that \f[C]yq\f[R] does not yet consider anchors when sorting by
keys - this may result in invalid yaml documents if your are using merge
anchors.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Sort keys of map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
c: frog
a: blah
b: bing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_keys(.)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: blah
b: bing
c: frog
\f[R]
.fi
.SS Sort keys recursively
.PP
Note the array elements are left unsorted, but maps inside arrays are
sorted
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
bParent:
  c: dog
  array:
    - 3
    - 1
    - 2
aParent:
  z: donkey
  x:
    - c: yum
      b: delish
    - b: ew
      a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_keys(..)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
aParent:
  x:
    - b: delish
      c: yum
    - a: apple
      b: ew
  z: donkey
bParent:
  array:
    - 3
    - 1
    - 2
  c: dog
\f[R]
.fi
.SH Sort
.PP
Sorts an array.
Use \f[C]sort\f[R] to sort an array as is, or \f[C]sort_by(exp)\f[R] to
sort by a particular expression (e.g.\ subfield).
.PP
To sort by descending order, pipe the results through the
\f[C]reverse\f[R] operator after sorting.
.PP
Note that at this stage, \f[C]yq\f[R] only sorts scalar fields.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Sort by string field
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: banana
- a: cat
- a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_by(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: apple
- a: banana
- a: cat
\f[R]
.fi
.SS Sort descending by string field
.PP
Use sort with reverse to sort in descending order.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: banana
- a: cat
- a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_by(.a) | reverse\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: cat
- a: banana
- a: apple
\f[R]
.fi
.SS Sort array in place
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cool:
  - a: banana
  - a: cat
  - a: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].cool |= sort_by(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool:
  - a: apple
  - a: banana
  - a: cat
\f[R]
.fi
.SS Sort array of objects by key
.PP
Note that you can give sort_by complex expressions, not just paths
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cool:
  - b: banana
  - a: banana
  - c: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].cool |= sort_by(keys | .[0])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cool:
  - a: banana
  - b: banana
  - c: banana
\f[R]
.fi
.SS Sort is stable
.PP
Note the order of the elements in unchanged when equal in sorting.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: banana
  b: 1
- a: banana
  b: 2
- a: banana
  b: 3
- a: banana
  b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_by(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: banana
  b: 1
- a: banana
  b: 2
- a: banana
  b: 3
- a: banana
  b: 4
\f[R]
.fi
.SS Sort by numeric field
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: 10
- a: 100
- a: 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort_by(.a)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: 1
- a: 10
- a: 100
\f[R]
.fi
.SS Sort, nulls come first
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 8
- 3
- null
- 6
- true
- false
- cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]sort\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- null
- false
- true
- 3
- 6
- 8
- cat
\f[R]
.fi
.SH Split into Documents
.PP
This operator splits all matches into separate documents
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Split empty
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]split_doc\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Split array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: cat
- b: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | split_doc\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
---
b: dog
\f[R]
.fi
.SH String Operators
.SS RegEx
.PP
This uses golangs native regex functions under the hood - See their
docs (https://github.com/google/re2/wiki/Syntax) for the supported
syntax.
.PP
Case insensitive tip: prefix the regex with \f[C](?i)\f[R] -
e.g.\ \f[C]test(\[dq](?i)cats)\[dq]\f[R].
.SS match(regEx)
.PP
This operator returns the substring match details of the given regEx.
.SS capture(regEx)
.PP
Capture returns named RegEx capture groups in a map.
Can be more convenient than \f[C]match\f[R] depending on what you are
doing.
.SS test(regEx)
.PP
Returns true if the string matches the RegEx, false otherwise.
.SS sub(regEx, replacement)
.PP
Substitutes matched substrings.
The first parameter is the regEx to match substrings within the original
string.
The second is a what to replace those matches with.
This can refer to capture groups from the first RegEx.
.SS String blocks, bash and newlines
.PP
Bash is notorious for chomping on precious trailing newline characters,
making it tricky to set strings with newlines properly.
In particular, the \f[C]$( exp )\f[R] \f[I]will trim trailing
newlines\f[R].
.PP
For instance to get this yaml:
.IP
.nf
\f[C]
a: |
  cat
\f[R]
.fi
.PP
Using \f[C]$( exp )\f[R] wont work, as it will trim the trailing new
line.
.IP
.nf
\f[C]
m=$(echo \[dq]cat\[rs]n\[dq]) yq -n \[aq].a = strenv(m)\[aq]
a: cat
\f[R]
.fi
.PP
However, using printf works:
.IP
.nf
\f[C]
printf -v m \[dq]cat\[rs]n\[dq] ; m=\[dq]$m\[dq] yq -n \[aq].a = strenv(m)\[aq]
a: |
  cat
\f[R]
.fi
.PP
As well as having multiline expressions:
.IP
.nf
\f[C]
m=\[dq]cat
\[dq]  yq -n \[aq].a = strenv(m)\[aq]
a: |
  cat
\f[R]
.fi
.PP
Similarly, if you\[cq]re trying to set the content from a file, and want
a trailing new line:
.IP
.nf
\f[C]
IFS= read -rd \[aq]\[aq] output < <(cat my_file)
output=$output ./yq \[aq].data.values = strenv(output)\[aq] first.yml
\f[R]
.fi
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS To up (upper) case
.PP
Works with unicode characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\['a]gua
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]upcase\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\['A]GUA
\f[R]
.fi
.SS To down (lower) case
.PP
Works with unicode characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\['A]gUA
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]downcase\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\['a]gua
\f[R]
.fi
.SS Join strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- meow
- 1
- null
- true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]join(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat; meow; 1; ; true
\f[R]
.fi
.SS Match string
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar foo
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]match(\[dq]foo\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
string: foo
offset: 0
length: 3
captures: []
\f[R]
.fi
.SS Match string, case insensitive
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar FOO
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][match(\[dq](?i)foo\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: foo
  offset: 0
  length: 3
  captures: []
- string: FOO
  offset: 8
  length: 3
  captures: []
\f[R]
.fi
.SS Match with global capture group
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
abc abc
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][match(\[dq](ab)(c)\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: abc
  offset: 0
  length: 3
  captures:
    - string: ab
      offset: 0
      length: 2
    - string: c
      offset: 2
      length: 1
- string: abc
  offset: 4
  length: 3
  captures:
    - string: ab
      offset: 4
      length: 2
    - string: c
      offset: 6
      length: 1
\f[R]
.fi
.SS Match with named capture groups
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo bar foo foo  foo
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][match(\[dq]foo (?P<bar123>bar)? foo\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: foo bar foo
  offset: 0
  length: 11
  captures:
    - string: bar
      offset: 4
      length: 3
      name: bar123
- string: foo  foo
  offset: 12
  length: 8
  captures:
    - string: null
      offset: -1
      length: 0
      name: bar123
\f[R]
.fi
.SS Capture named groups into a map
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
xyzzy-14
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]capture(\[dq](?P<a>[a-z]+)-(?P<n>[0-9]+)\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: xyzzy
n: \[dq]14\[dq]
\f[R]
.fi
.SS Match without global flag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]match(\[dq]cat\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
string: cat
offset: 0
length: 3
captures: []
\f[R]
.fi
.SS Match with global flag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq][match(\[dq]cat\[dq]; \[dq]g\[dq])]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- string: cat
  offset: 0
  length: 3
  captures: []
- string: cat
  offset: 4
  length: 3
  captures: []
\f[R]
.fi
.SS Test using regex
.PP
Like jq\[cq]q equivalent, this works like match but only returns
true/false instead of full match details
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] | test(\[dq]at\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
true
false
\f[R]
.fi
.SS Substitute / Replace string
.PP
This uses golang regex, described
here (https://github.com/google/re2/wiki/Syntax) Note the use of
\f[C]|=\f[R] to run in context of the current string value.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: dogs are great
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a |= sub(\[dq]dogs\[dq], \[dq]cats\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cats are great
\f[R]
.fi
.SS Substitute / Replace string with regex
.PP
This uses golang regex, described
here (https://github.com/google/re2/wiki/Syntax) Note the use of
\f[C]|=\f[R] to run in context of the current string value.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: heat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] |= sub(\[dq](a)\[dq], \[dq]${1}r\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cart
b: heart
\f[R]
.fi
.SS Custom types: that are really strings
.PP
When custom tags are encountered, yq will try to decode the underlying
type.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse cat
b: !goat heat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] |= sub(\[dq](a)\[dq], \[dq]${1}r\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse cart
b: !goat heart
\f[R]
.fi
.SS Split strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat; meow; 1; ; true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]split(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- cat
- meow
- \[dq]1\[dq]
- \[dq]\[dq]
- \[dq]true\[dq]
\f[R]
.fi
.SS Split strings one match
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
word
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]split(\[dq]; \[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- word
\f[R]
.fi
.SH Style
.PP
The style operator can be used to get or set the style of nodes
(e.g.\ string style, yaml style)
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Update and set style of a particular node (simple)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b = \[dq]new\[dq] | .a.b style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SS Update and set style of a particular node using path variables
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with(.a.b ; . = \[dq]new\[dq] | . style=\[dq]double\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SS Set tagged style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]tagged\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
!!map
a: !!str cat
b: !!int 5
c: !!float 3.2
e: !!bool true
\f[R]
.fi
.SS Set double quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[dq]cat\[dq]
b: \[dq]5\[dq]
c: \[dq]3.2\[dq]
e: \[dq]true\[dq]
\f[R]
.fi
.SS Set double quote style on map keys too
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]... style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\[dq]a\[dq]: \[dq]cat\[dq]
\[dq]b\[dq]: \[dq]5\[dq]
\[dq]c\[dq]: \[dq]3.2\[dq]
\[dq]e\[dq]: \[dq]true\[dq]
\f[R]
.fi
.SS Set single quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]single\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]cat\[aq]
b: \[aq]5\[aq]
c: \[aq]3.2\[aq]
e: \[aq]true\[aq]
\f[R]
.fi
.SS Set literal quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]literal\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: |-
  cat
b: |-
  5
c: |-
  3.2
e: |-
  true
\f[R]
.fi
.SS Set folded quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]folded\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: >-
  cat
b: >-
  5
c: >-
  3.2
e: >-
  true
\f[R]
.fi
.SS Set flow quote style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. style=\[dq]flow\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{a: cat, b: 5, c: 3.2, e: true}
\f[R]
.fi
.SS Reset style - or pretty print
.PP
Set empty (default) quote style, note the usage of \f[C]...\f[R] to
match keys too.
Note that there is a \f[C]--prettyPrint/-P\f[R] short flag for this.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\[dq]b\[dq]: 5
\[aq]c\[aq]: 3.2
\[dq]e\[dq]: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]... style=\[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.SS Set style relatively with assign-update
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: single
b: double
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] style |= .\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: \[aq]single\[aq]
b: \[dq]double\[dq]
\f[R]
.fi
.SS Read style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
{a: \[dq]cat\[dq], b: \[aq]thing\[aq]}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. | style\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
flow
double
single
\f[R]
.fi
.SH Subtract
.PP
You can use subtract to subtract numbers, as well as removing elements
from an array.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Array subtraction
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq][1,2] - [2,3]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
\f[R]
.fi
.SS Array subtraction with nested array
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq][[1], 1, 2] - [[1], 3]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
\f[R]
.fi
.SS Array subtraction with nested object
.PP
Note that order of the keys does not matter
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- a: b
  c: d
- a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]. - [{\[dq]c\[dq]: \[dq]d\[dq], \[dq]a\[dq]: \[dq]b\[dq]}]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- a: b
\f[R]
.fi
.SS Number subtraction - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1.5
b: 4.5
\f[R]
.fi
.SS Number subtraction - float
.PP
If the lhs or rhs are floats then the expression will be calculated with
floats.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4.5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1.5
b: 4.5
\f[R]
.fi
.SS Number subtraction - int
.PP
If both the lhs and rhs are ints then the expression will be calculated
with ints.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 4
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a = .a - .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: -1
b: 4
\f[R]
.fi
.SS Decrement numbers
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 3
b: 5
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] -= 1\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2
b: 4
\f[R]
.fi
.SS Date subtraction
.PP
You can subtract durations from dates.
Assumes RFC3339 date time format, see date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: 2021-01-01T03:10:00Z
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a -= \[dq]3h10m\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: 2021-01-01T00:00:00Z
\f[R]
.fi
.SS Date subtraction - custom format
.PP
Use with_dtf to specify your datetime format.
See date-time
operators (https://mikefarah.gitbook.io/yq/operators/date-time-operators)
for more information.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 6:00AM GMT
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with_dtf(\[dq]Monday, 02-Jan-06 at 3:04PM MST\[dq], .a -= \[dq]3h1m\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Saturday, 15-Dec-01 at 2:59AM GMT
\f[R]
.fi
.SS Custom types: that are really numbers
.PP
When custom tags are encountered, yq will try to decode the underlying
type.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: !horse 2
b: !goat 1
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a -= .b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !horse 1
b: !goat 1
\f[R]
.fi
.SH Tag
.PP
The tag operator can be used to get or set the tag of nodes
(e.g.\ \f[C]!!str\f[R], \f[C]!!int\f[R], \f[C]!!bool\f[R]).
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Get tag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
f: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. | tag\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
!!map
!!str
!!int
!!float
!!bool
!!seq
\f[R]
.fi
.SS type is an alias for tag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
f: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].. | type\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
!!map
!!str
!!int
!!float
!!bool
!!seq
\f[R]
.fi
.SS Set custom tag
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: str
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a tag = \[dq]!!mikefarah\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: !!mikefarah str
\f[R]
.fi
.SS Find numbers and convert them to strings
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
b: 5
c: 3.2
e: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq](.. | select(tag == \[dq]!!int\[dq])) tag= \[dq]!!str\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: cat
b: \[dq]5\[dq]
c: 3.2
e: true
\f[R]
.fi
.SH Traverse (Read)
.PP
This is the simplest (and perhaps most used) operator, it is used to
navigate deeply into yaml structures.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Simple map navigation
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: apple
\f[R]
.fi
.SS Splat
.PP
Often used to pipe children into other operators
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- b: apple
- c: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
b: apple
c: banana
\f[R]
.fi
.SS Optional Splat
.PP
Just like splat, but won\[cq]t error if you run it against scalars
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Special characters
.PP
Use quotes with brackets around path elements with special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]{}\[dq]: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[\[dq]{}\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Nested special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  \[dq]key.withdots\[dq]:
    \[dq]another.key\[dq]: apple
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a[\[dq]key.withdots\[dq]][\[dq]another.key\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
apple
\f[R]
.fi
.SS Keys with spaces
.PP
Use quotes with brackets around path elements with special characters
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]red rabbit\[dq]: frog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[\[dq]red rabbit\[dq]]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Dynamic keys
.PP
Expressions within [] can be used to dynamically lookup / calculate keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
b: apple
apple: crispy yum
banana: soft yum
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[.b]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
crispy yum
\f[R]
.fi
.SS Children don\[cq]t exist
.PP
Nodes are added dynamically while traversing
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
c: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
null
\f[R]
.fi
.SS Optional identifier
.PP
Like jq, does not output an error when the yaml is not an array or
object as expected
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a?\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
\f[R]
.fi
.SS Wildcard matching
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  cat: apple
  mad: things
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.\[dq]*a*\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
apple
things
\f[R]
.fi
.SS Aliases
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
*cat
\f[R]
.fi
.SS Traversing aliases with splat
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Traversing aliases explicitly
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: &cat
  c: frog
b: *cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].b.c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
frog
\f[R]
.fi
.SS Traversing arrays by index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
\f[R]
.fi
.SS Traversing nested arrays by index
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
[[], [cat]]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[1][0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Maps with numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
2: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[2]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Maps with non existing numeric keys
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: b
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[0]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
null
\f[R]
.fi
.SS Traversing merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar.a\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_a
\f[R]
.fi
.SS Traversing merge anchors with override
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar.c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_c
\f[R]
.fi
.SS Traversing merge anchors with local override
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar.thing\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foobar_thing
\f[R]
.fi
.SS Splatting merge anchors
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobar[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
foo_c
foo_a
foobar_thing
\f[R]
.fi
.SS Traversing merge anchor lists
.PP
Note that the later merge anchors override previous
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobarList.thing\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bar_thing
\f[R]
.fi
.SS Splatting merge anchor lists
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
foo: &foo
  a: foo_a
  thing: foo_thing
  c: foo_c
bar: &bar
  b: bar_b
  thing: bar_thing
  c: bar_c
foobarList:
  b: foobarList_b
  !!merge <<:
    - *foo
    - *bar
  c: foobarList_c
foobar:
  c: foobar_c
  !!merge <<: *foo
  thing: foobar_thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].foobarList[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
bar_b
foo_a
bar_thing
foobarList_c
\f[R]
.fi
.SS Select multiple indices
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  - a
  - b
  - c
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a[0, 2]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a
c
\f[R]
.fi
.SH Union
.PP
This operator is used to combine different results together.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Combine scalars
.PP
Running
.IP
.nf
\f[C]
yq --null-input \[aq]1, true, \[dq]cat\[dq]\[aq]
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
1
true
cat
\f[R]
.fi
.SS Combine selected paths
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: fieldA
b: fieldB
c: fieldC
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a, .c\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
fieldA
fieldC
\f[R]
.fi
.SH Unique
.PP
This is used to filter out duplicated items in an array.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Unique array of scalars (string/numbers)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- 1
- 2
- 3
- 2
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]unique\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- 1
- 2
- 3
\f[R]
.fi
.SS Unique nulls
.PP
Unique works on the node value, so it considers different
representations of nulls to be different
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- \[ti]
- null
- \[ti]
- null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]unique\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- \[ti]
- null
\f[R]
.fi
.SS Unique all nulls
.PP
Run against the node tag to unique all the nulls
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- \[ti]
- null
- \[ti]
- null
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]unique_by(tag)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- \[ti]
\f[R]
.fi
.SS Unique array object fields
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- name: harry
  pet: cat
- name: billy
  pet: dog
- name: harry
  pet: dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]unique_by(.name)\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
- name: harry
  pet: cat
- name: billy
  pet: dog
\f[R]
.fi
.SH Variable Operators
.PP
Like the \f[C]jq\f[R] equivalents, variables are sometimes required for
the more complex expressions (or swapping values between fields).
.PP
Note that there is also an additional \f[C]ref\f[R] operator that holds
a reference (instead of a copy) of the path, allowing you to make
multiple changes to the same path.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Single value variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a as $foo | $foo\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
\f[R]
.fi
.SS Multi value variable
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
- cat
- dog
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].[] as $foo | $foo\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat
dog
\f[R]
.fi
.SS Using variables as a lookup
.PP
Example taken from
jq (https://stedolan.github.io/jq/manual/#Variable/SymbolicBindingOperator:...as$identifier%7C...)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
\[dq]posts\[dq]:
  - \[dq]title\[dq]: Frist psot
    \[dq]author\[dq]: anon
  - \[dq]title\[dq]: A well-written article
    \[dq]author\[dq]: person1
\[dq]realnames\[dq]:
  \[dq]anon\[dq]: Anonymous Coward
  \[dq]person1\[dq]: Person McPherson
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].realnames as $names | .posts[] | {\[dq]title\[dq]:.title, \[dq]author\[dq]: $names[.author]}\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
title: Frist psot
author: Anonymous Coward
title: A well-written article
author: Person McPherson
\f[R]
.fi
.SS Using variables to swap values
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a: a_value
b: b_value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a as $x  | .b as $y | .b = $x | .a = $y\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: b_value
b: a_value
\f[R]
.fi
.SS Use ref to reference a path repeatedly
.PP
Note: You may find the \f[C]with\f[R] operator more useful.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  b: thing
  c: something
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq].a.b ref $x | $x = \[dq]new\[dq] | $x style=\[dq]double\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  b: \[dq]new\[dq]
  c: something
\f[R]
.fi
.SH With
.PP
Use the \f[C]with\f[R] operator to conveniently make multiple updates to
a deeply nested path, or to update array elements relatively to each
other.
The first argument expression sets the root context, and the second
expression runs against that root context.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Update and style
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  deeply:
    nested: value
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with(.a.deeply.nested; . = \[dq]newValue\[dq] | . style=\[dq]single\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  deeply:
    nested: \[aq]newValue\[aq]
\f[R]
.fi
.SS Update multiple deeply nested properties
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
a:
  deeply:
    nested: value
    other: thing
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with(.a.deeply; .nested = \[dq]newValue\[dq] | .other= \[dq]newThing\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a:
  deeply:
    nested: newValue
    other: newThing
\f[R]
.fi
.SS Update array elements relatively
.PP
The second expression runs with each element of the array as it\[cq]s
contextual root.
This allows you to make updates relative to the element.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
myArray:
  - a: apple
  - a: banana
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq \[aq]with(.myArray[]; .b = .a + \[dq] yum\[dq])\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
myArray:
  - a: apple
    b: apple yum
  - a: banana
    b: banana yum
\f[R]
.fi
.SH JSON
.PP
Encode and decode to and from JSON.
Note that YAML is a \f[I]superset\f[R] of JSON - so \f[C]yq\f[R] can
read any json file without doing anything special.
.PP
This means you don\[cq]t need to `convert' a JSON file to YAML - however
if you want idiomatic YAML styling, then you can use the
\f[C]-P/--prettyPrint\f[R] flag, see examples below.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Parse json: simple
.PP
JSON is a subset of yaml, so all you need to do is prettify the output
.PP
Given a sample.json file of:
.IP
.nf
\f[C]
{\[dq]cat\[dq]: \[dq]meow\[dq]}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -P \[aq].\[aq] sample.json
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat: meow
\f[R]
.fi
.SS Parse json: complex
.PP
JSON is a subset of yaml, so all you need to do is prettify the output
.PP
Given a sample.json file of:
.IP
.nf
\f[C]
{\[dq]a\[dq]:\[dq]Easy! as one two three\[dq],\[dq]b\[dq]:{\[dq]c\[dq]:2,\[dq]d\[dq]:[3,4]}}
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -P \[aq].\[aq] sample.json
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
a: Easy! as one two three
b:
  c: 2
  d:
    - 3
    - 4
\f[R]
.fi
.SS Encode json: simple
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: meow
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=json \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{
  \[dq]cat\[dq]: \[dq]meow\[dq]
}
\f[R]
.fi
.SS Encode json: simple - in one line
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: meow # this is a comment, and it will be dropped.
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=json -I=0 \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{\[dq]cat\[dq]:\[dq]meow\[dq]}
\f[R]
.fi
.SS Encode json: comments
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: meow # this is a comment, and it will be dropped.
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=json \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{
  \[dq]cat\[dq]: \[dq]meow\[dq]
}
\f[R]
.fi
.SS Encode json: anchors
.PP
Anchors are dereferenced
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: &ref meow
anotherCat: *ref
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=json \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{
  \[dq]cat\[dq]: \[dq]meow\[dq],
  \[dq]anotherCat\[dq]: \[dq]meow\[dq]
}
\f[R]
.fi
.SS Encode json: multiple results
.PP
Each matching node is converted into a json doc.
This is best used with 0 indent (json document per line)
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
things: [{stuff: cool}, {whatever: cat}]
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=json -I=0 \[aq].things[]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
{\[dq]stuff\[dq]:\[dq]cool\[dq]}
{\[dq]whatever\[dq]:\[dq]cat\[dq]}
\f[R]
.fi
.SH Properties
.PP
Encode to a property file (decode not yet supported).
Line comments on value nodes will be copied across.
.PP
By default, empty maps and arrays are not encoded - see below for an
example on how to encode a value for these.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Encode properties
.PP
Note that empty arrays and maps are not encoded by default.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# block comments don\[aq]t come through
person: # neither do comments on maps
    name: Mike # comments on values appear
    pets: 
    - cat # comments on array values appear
    food: [pizza] # comments on arrays do not
emptyArray: []
emptyMap: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=props sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# comments on values appear
person.name = Mike

# comments on array values appear
person.pets.0 = cat
person.food.0 = pizza
\f[R]
.fi
.SS Encode properties: no comments
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# block comments don\[aq]t come through
person: # neither do comments on maps
    name: Mike # comments on values appear
    pets: 
    - cat # comments on array values appear
    food: [pizza] # comments on arrays do not
emptyArray: []
emptyMap: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=props \[aq]... comments = \[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
person.name = Mike
person.pets.0 = cat
person.food.0 = pizza
\f[R]
.fi
.SS Encode properties: include empty maps and arrays
.PP
Use a yq expression to set the empty maps and sequences to your desired
value.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# block comments don\[aq]t come through
person: # neither do comments on maps
    name: Mike # comments on values appear
    pets: 
    - cat # comments on array values appear
    food: [pizza] # comments on arrays do not
emptyArray: []
emptyMap: []
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=props \[aq](.. | select( (tag == \[dq]!!map\[dq] or tag ==\[dq]!!seq\[dq]) and length == 0)) = \[dq]\[dq]\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# comments on values appear
person.name = Mike

# comments on array values appear
person.pets.0 = cat
person.food.0 = pizza
emptyArray = 
emptyMap = 
\f[R]
.fi
.SS Decode properties
.PP
Given a sample.properties file of:
.IP
.nf
\f[C]
# comments on values appear
person.name = Mike

# comments on array values appear
person.pets.0 = cat
person.food.0 = pizza
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=props sample.properties
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
person:
    name: Mike # comments on values appear
    pets:
        - cat # comments on array values appear
    food:
        - pizza
\f[R]
.fi
.SS Roundtrip
.PP
Given a sample.properties file of:
.IP
.nf
\f[C]
# comments on values appear
person.name = Mike

# comments on array values appear
person.pets.0 = cat
person.food.0 = pizza
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=props -o=props \[aq].person.pets.0 = \[dq]dog\[dq]\[aq] sample.properties
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# comments on values appear
person.name = Mike

# comments on array values appear
person.pets.0 = dog
person.food.0 = pizza
\f[R]
.fi
.SH XML
.PP
Encode and decode to and from XML.
Whitespace is not conserved for round trips - but the order of the
fields are.
.PP
Consecutive xml nodes with the same name are assumed to be arrays.
.PP
XML content data and attributes are created as fields.
This can be controlled by the \f[C]\[aq]--xml-attribute-prefix\f[R] and
\f[C]--xml-content-name\f[R] flags - see below for examples.
.PP
{% hint style=\[lq]warning\[rq] %} Note that versions prior to 4.18
require the `eval/e' command to be specified. 
.PP
\f[C]yq e <exp> <file>\f[R] {% endhint %}
.SS Parse xml: simple
.PP
Notice how all the values are strings, see the next example on how you
can fix that.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq] encoding=\[dq]UTF-8\[dq]?>
<cat>
  <says>meow</says>
  <legs>4</legs>
  <cute>true</cute>
</cat>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat:
  says: meow
  legs: \[dq]4\[dq]
  cute: \[dq]true\[dq]
\f[R]
.fi
.SS Parse xml: number
.PP
All values are assumed to be strings when parsing XML, but you can use
the \f[C]from_yaml\f[R] operator on all the strings values to autoparse
into the correct type.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq] encoding=\[dq]UTF-8\[dq]?>
<cat>
  <says>meow</says>
  <legs>4</legs>
  <cute>true</cute>
</cat>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq] (.. | select(tag == \[dq]!!str\[dq])) |= from_yaml\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat:
  says: meow
  legs: 4
  cute: true
\f[R]
.fi
.SS Parse xml: array
.PP
Consecutive nodes with identical xml names are assumed to be arrays.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq] encoding=\[dq]UTF-8\[dq]?>
<animal>cat</animal>
<animal>goat</animal>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
animal:
  - cat
  - goat
\f[R]
.fi
.SS Parse xml: attributes
.PP
Attributes are converted to fields, with the default attribute prefix
`+'.
Use \[cq]\[en]xml-attribute-prefix\[ga] to set your own.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq] encoding=\[dq]UTF-8\[dq]?>
<cat legs=\[dq]4\[dq]>
  <legs>7</legs>
</cat>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat:
  +legs: \[dq]4\[dq]
  legs: \[dq]7\[dq]
\f[R]
.fi
.SS Parse xml: attributes with content
.PP
Content is added as a field, using the default content name of
\f[C]+content\f[R].
Use \f[C]--xml-content-name\f[R] to set your own.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq] encoding=\[dq]UTF-8\[dq]?>
<cat legs=\[dq]4\[dq]>meow</cat>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
cat:
  +content: meow
  +legs: \[dq]4\[dq]
\f[R]
.fi
.SS Parse xml: custom dtd
.PP
DTD entities are ignored.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<?xml version=\[dq]1.0\[dq]?>
<!DOCTYPE root [
<!ENTITY writer \[dq]Blah.\[dq]>
<!ENTITY copyright \[dq]Blah\[dq]>
]>
<root>
    <item>&writer;&copyright;</item>
</root>
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
root:
  item: \[aq]&writer;&copyright;\[aq]
\f[R]
.fi
.SS Parse xml: with comments
.PP
A best attempt is made to preserve comments.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<!-- before cat -->
<cat>
    <!-- in cat before -->
    <x>3<!-- multi
line comment 
for x --></x>
    <!-- before y -->
    <y>
        <!-- in y before -->
        <d><!-- in d before -->z<!-- in d after --></d>
        
        <!-- in y after -->
    </y>
    <!-- in_cat_after -->
</cat>
<!-- after cat -->
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
# before cat
cat:
  # in cat before
  x: \[dq]3\[dq] # multi
  # line comment 
  # for x
  # before y

  y:
    # in y before
    # in d before
    d: z # in d after
    # in y after
  # in_cat_after
# after cat
\f[R]
.fi
.SS Encode xml: simple
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat: purrs
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=xml \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<cat>purrs</cat>
\f[R]
.fi
.SS Encode xml: array
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
pets:
  cat:
    - purrs
    - meows
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=xml \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<pets>
  <cat>purrs</cat>
  <cat>meows</cat>
</pets>
\f[R]
.fi
.SS Encode xml: attributes
.PP
Fields with the matching xml-attribute-prefix are assumed to be
attributes.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat:
  +name: tiger
  meows: true
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=xml \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<cat name=\[dq]tiger\[dq]>
  <meows>true</meows>
</cat>
\f[R]
.fi
.SS Encode xml: attributes with content
.PP
Fields with the matching xml-content-name is assumed to be content.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
cat:
  +name: tiger
  +content: cool
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=xml \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<cat name=\[dq]tiger\[dq]>cool</cat>
\f[R]
.fi
.SS Encode xml: comments
.PP
A best attempt is made to copy comments to xml.
.PP
Given a sample.yml file of:
.IP
.nf
\f[C]
# above_cat
cat: # inline_cat
  # above_array
  array: # inline_array
    - val1 # inline_val1
    # above_val2
    - val2 # inline_val2
# below_cat
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -o=xml \[aq].\[aq] sample.yml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<!-- above_cat inline_cat --><cat><!-- above_array inline_array -->
  <array>val1<!-- inline_val1 --></array>
  <array><!-- above_val2 -->val2<!-- inline_val2 --></array>
</cat><!-- below_cat -->
\f[R]
.fi
.SS Round trip: with comments
.PP
A best effort is made, but comment positions and white space are not
preserved perfectly.
.PP
Given a sample.xml file of:
.IP
.nf
\f[C]
<!-- before cat -->
<cat>
    <!-- in cat before -->
    <x>3<!-- multi
line comment 
for x --></x>
    <!-- before y -->
    <y>
        <!-- in y before -->
        <d><!-- in d before -->z<!-- in d after --></d>
        
        <!-- in y after -->
    </y>
    <!-- in_cat_after -->
</cat>
<!-- after cat -->
\f[R]
.fi
.PP
then
.IP
.nf
\f[C]
yq -p=xml -o=xml \[aq].\[aq] sample.xml
\f[R]
.fi
.PP
will output
.IP
.nf
\f[C]
<!-- before cat --><cat><!-- in cat before -->
  <x>3<!-- multi
line comment 
for x --></x><!-- before y -->
  <y><!-- in y before
in d before -->
    <d>z<!-- in d after --></d><!-- in y after -->
  </y><!-- in_cat_after -->
</cat><!-- after cat -->
\f[R]
.fi
.SH AUTHORS
Mike Farah.
